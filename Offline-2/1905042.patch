diff --git a/.vscode/settings.json b/.vscode/settings.json
new file mode 100644
index 0000000..bfe7e6a
--- /dev/null
+++ b/.vscode/settings.json
@@ -0,0 +1,8 @@
+{
+    "files.associations": {
+        "user.h": "c",
+        "stat.h": "c",
+        "param.h": "c",
+        "types.h": "c"
+    }
+}
\ No newline at end of file
diff --git a/1905.patch b/1905.patch
new file mode 100644
index 0000000..769c182
--- /dev/null
+++ b/1905.patch
@@ -0,0 +1,635 @@
+diff --git a/.vscode/settings.json b/.vscode/settings.json
+new file mode 100644
+index 0000000..bfe7e6a
+--- /dev/null
++++ b/.vscode/settings.json
+@@ -0,0 +1,8 @@
++{
++    "files.associations": {
++        "user.h": "c",
++        "stat.h": "c",
++        "param.h": "c",
++        "types.h": "c"
++    }
++}
+\ No newline at end of file
+diff --git a/1905042.patch b/1905042.patch
+new file mode 100644
+index 0000000..e69de29
+diff --git a/Makefile b/Makefile
+index 39a99d7..0311ce7 100644
+--- a/Makefile
++++ b/Makefile
+@@ -132,6 +132,10 @@ UPROGS=\
+	$U/_grind\
+	$U/_wc\
+	$U/_zombie\
++	$U/_myProg\
++	$U/_trace\
++	$U/_history\
++	$U/_exit\
+
+ fs.img: mkfs/mkfs README $(UPROGS)
+	mkfs/mkfs fs.img README $(UPROGS)
+diff --git a/kernel/param.h b/kernel/param.h
+index 6624bff..b48f7ce 100644
+--- a/kernel/param.h
++++ b/kernel/param.h
+@@ -10,4 +10,4 @@
+ #define LOGSIZE      (MAXOPBLOCKS*3)  // max data blocks in on-disk log
+ #define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache
+ #define FSSIZE       2000  // size of file system in blocks
+-#define MAXPATH      128   // maximum file path name
++#define MAXPATH      128   // maximum file path name
+\ No newline at end of file
+diff --git a/kernel/proc.c b/kernel/proc.c
+index 959b778..1011b61 100644
+--- a/kernel/proc.c
++++ b/kernel/proc.c
+@@ -322,6 +322,8 @@ fork(void)
+   np->state = RUNNABLE;
+   release(&np->lock);
+
++
++np->traceId=p->traceId; // trace the new process
+   return pid;
+ }
+
+diff --git a/kernel/proc.h b/kernel/proc.h
+index d021857..d26f9f5 100644
+--- a/kernel/proc.h
++++ b/kernel/proc.h
+@@ -84,7 +84,9 @@ enum procstate { UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
+ // Per-process state
+ struct proc {
+   struct spinlock lock;
+-
++  //vars for trace syscall
++  int traceId;
++  char *args;
+   // p->lock must be held when using these:
+   enum procstate state;        // Process state
+   void *chan;                  // If non-zero, sleeping on chan
+@@ -105,3 +107,9 @@ struct proc {
+   struct inode *cwd;           // Current directory
+   char name[16];               // Process name (debugging)
+ };
++
++struct syscall_stat{
++char syscall_name[16];
++int count;
++int accum_time;
++};
+\ No newline at end of file
+diff --git a/kernel/syscall.c b/kernel/syscall.c
+index ed65409..4aececd 100644
+--- a/kernel/syscall.c
++++ b/kernel/syscall.c
+@@ -8,24 +8,22 @@
+ #include "defs.h"
+
+ // Fetch the uint64 at addr from the current process.
+-int
+-fetchaddr(uint64 addr, uint64 *ip)
++int fetchaddr(uint64 addr, uint64 *ip)
+ {
+   struct proc *p = myproc();
+-  if(addr >= p->sz || addr+sizeof(uint64) > p->sz) // both tests needed, in case of overflow
++  if (addr >= p->sz || addr + sizeof(uint64) > p->sz) // both tests needed, in case of overflow
+     return -1;
+-  if(copyin(p->pagetable, (char *)ip, addr, sizeof(*ip)) != 0)
++  if (copyin(p->pagetable, (char *)ip, addr, sizeof(*ip)) != 0)
+     return -1;
+   return 0;
+ }
+
+ // Fetch the nul-terminated string at addr from the current process.
+ // Returns length of string, not including nul, or -1 for error.
+-int
+-fetchstr(uint64 addr, char *buf, int max)
++int fetchstr(uint64 addr, char *buf, int max)
+ {
+   struct proc *p = myproc();
+-  if(copyinstr(p->pagetable, buf, addr, max) < 0)
++  if (copyinstr(p->pagetable, buf, addr, max) < 0)
+     return -1;
+   return strlen(buf);
+ }
+@@ -34,7 +32,8 @@ static uint64
+ argraw(int n)
+ {
+   struct proc *p = myproc();
+-  switch (n) {
++  switch (n)
++  {
+   case 0:
+     return p->trapframe->a0;
+   case 1:
+@@ -53,8 +52,7 @@ argraw(int n)
+ }
+
+ // Fetch the nth 32-bit system call argument.
+-void
+-argint(int n, int *ip)
++void argint(int n, int *ip)
+ {
+   *ip = argraw(n);
+ }
+@@ -62,8 +60,7 @@ argint(int n, int *ip)
+ // Retrieve an argument as a pointer.
+ // Doesn't check for legality, since
+ // copyin/copyout will do that.
+-void
+-argaddr(int n, uint64 *ip)
++void argaddr(int n, uint64 *ip)
+ {
+   *ip = argraw(n);
+ }
+@@ -71,12 +68,14 @@ argaddr(int n, uint64 *ip)
+ // Fetch the nth word-sized system call argument as a null-terminated string.
+ // Copies into buf, at most max.
+ // Returns string length if OK (including nul), -1 if error.
+-int
+-argstr(int n, char *buf, int max)
++int argstr(int n, char *buf, int max)
+ {
+   uint64 addr;
+   argaddr(n, &addr);
+-  return fetchstr(addr, buf, max);
++  int ret = 0;
++  fetchstr(addr, buf, max);
++  // printf("%d  %d %s",n,max,buf);
++  return ret;
+ }
+
+ // Prototypes for the functions that handle system calls.
+@@ -101,47 +100,204 @@ extern uint64 sys_unlink(void);
+ extern uint64 sys_link(void);
+ extern uint64 sys_mkdir(void);
+ extern uint64 sys_close(void);
++extern uint64 sys_trace(void); // add trace systemcall step 4-a
++extern uint64 sys_history(void); // add history systemcall step 4-a
++extern uint64 sys_terminate(void);
+
+ // An array mapping syscall numbers from syscall.h
+ // to the function that handles the system call.
+ static uint64 (*syscalls[])(void) = {
+-[SYS_fork]    sys_fork,
+-[SYS_exit]    sys_exit,
+-[SYS_wait]    sys_wait,
+-[SYS_pipe]    sys_pipe,
+-[SYS_read]    sys_read,
+-[SYS_kill]    sys_kill,
+-[SYS_exec]    sys_exec,
+-[SYS_fstat]   sys_fstat,
+-[SYS_chdir]   sys_chdir,
+-[SYS_dup]     sys_dup,
+-[SYS_getpid]  sys_getpid,
+-[SYS_sbrk]    sys_sbrk,
+-[SYS_sleep]   sys_sleep,
+-[SYS_uptime]  sys_uptime,
+-[SYS_open]    sys_open,
+-[SYS_write]   sys_write,
+-[SYS_mknod]   sys_mknod,
+-[SYS_unlink]  sys_unlink,
+-[SYS_link]    sys_link,
+-[SYS_mkdir]   sys_mkdir,
+-[SYS_close]   sys_close,
++    [SYS_fork] sys_fork,
++    [SYS_exit] sys_exit,
++    [SYS_wait] sys_wait,
++    [SYS_pipe] sys_pipe,
++    [SYS_read] sys_read,
++    [SYS_kill] sys_kill,
++    [SYS_exec] sys_exec,
++    [SYS_fstat] sys_fstat,
++    [SYS_chdir] sys_chdir,
++    [SYS_dup] sys_dup,
++    [SYS_getpid] sys_getpid,
++    [SYS_sbrk] sys_sbrk,
++    [SYS_sleep] sys_sleep,
++    [SYS_uptime] sys_uptime,
++    [SYS_open] sys_open,
++    [SYS_write] sys_write,
++    [SYS_mknod] sys_mknod,
++    [SYS_unlink] sys_unlink,
++    [SYS_link] sys_link,
++    [SYS_mkdir] sys_mkdir,
++    [SYS_close] sys_close,
++    [SYS_trace] sys_trace, // add trace systemcall step 4-b
++    [SYS_history] sys_history,
++    [SYS_terminate] sys_terminate,
+ };
++void printArgs(int num);
++char *syscall_names[] = {"","fork", "exit", "wait", "pipe", "read", "kill", "exec", "fstat", "chdir", "dup", "getpid",
++                         "sbrk", "sleep", "uptime", "open", "write", "mknod", "unlink", "link", "mkdir", "close", "trace","terminate"};
++struct syscall_stat stats[] = {
++  {"",0,0},
++  {"fork",0,0},
++  {"exit",0,0},
++  {"wait",0,0},
++  {"pipe",0,0},
++  {"read",0,0},
++  {"kill",0,0},
++  {"exec",0,0},
++  {"fstat",0,0},
++  {"chdir",0,0},
++  {"dup",0,0},
++  {"getpid",0,0},
++  {"sbrk",0,0},
++  {"sleep",0,0},
++  {"uptime",0,0},
++  {"open",0,0},
++  {"write",0,0},
++  {"mknod",0,0},
++  {"unlink",0,0},
++  {"link",0,0},
++  {"mkdir",0,0},
++  {"close",0,0},
++  {"trace",0,0},
++  {"history",0,0},
++  {"terminate",0,0},
+
+-void
+-syscall(void)
++};
++struct spinlock mylock;
++
++void syscall(void)
+ {
+   int num;
+   struct proc *p = myproc();
+
+   num = p->trapframe->a7;
+-  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
+-    // Use num to lookup the system call function for num, call it,
++  if (num > 0 && num < NELEM(syscalls) && syscalls[num])
++  {
++
++
++
++    if (p->traceId == num)
++    {
++
++
++      printf("pid: %d, syscall: %s, args: (", p->pid, syscall_names[num]);
++     printArgs(num);
++
++    }
++      // Use num to lookup the system call function for num, call it,
+     // and store its return value in p->trapframe->a0
++    acquire(&mylock);
++    stats[num].count++;
++    release(&mylock);
++
++    uint iticks,fticks;
++    acquire(&mylock);
++    iticks=ticks;
++    release(&mylock);
++
+     p->trapframe->a0 = syscalls[num]();
+-  } else {
++
++     acquire(&mylock);
++    fticks=ticks;
++    release(&mylock);
++     acquire(&mylock);
++    stats[num].accum_time+=fticks-iticks;
++    release(&mylock);
++    if (p->traceId == num)
++    {
++      // printing trace systemcall details
++      // printf("\npid: %d,syscall: %s,(%s) return value: %d\n",p->pid,,p->name,p->trapframe->a0);
++      printf("), return: %d\n", p->trapframe->a0);
++    }
++  }
++  else
++  {
+     printf("%d %s: unknown sys call %d\n",
+-            p->pid, p->name, num);
++           p->pid, p->name, num);
+     p->trapframe->a0 = -1;
+   }
+ }
++
++void printArgs(int num)
++{
++   if (num == SYS_exit || num == SYS_kill || num == SYS_sbrk || num == SYS_sleep || num == SYS_trace || num == SYS_dup ||num == SYS_close)
++      {
++        int arg;
++        argint(0, &arg);
++        printf("%d",arg);
++
++      }
++      else if (num == SYS_wait || num == SYS_pipe)
++      {
++        uint64 addr;
++        argaddr(0, &addr);
++        printf("%p", addr);
++
++      }
++      else if (num == SYS_fstat)
++      {
++        int arg0;
++        uint64 arg1;
++        argint(0,&arg0);
++        argaddr(1,&arg1);
++        printf("%d, %p",arg0,arg1);
++      }
++
++       else if (num == SYS_exec)
++      {
++        char arg0[MAXPATH];
++        uint64 arg1;
++        argaddr(1, &arg1);
++
++         if (argstr(0, arg0, MAXPATH) < 0)
++        {
++          printf("error line 231 syscall.c ");
++        }
++        else
++        {
++          printf("%s, %p", arg0, arg1);
++        }
++      }
++      else if (num == SYS_chdir || num == SYS_mknod || num == SYS_unlink)
++      {
++        char arg0[128];
++        if(argstr(0,arg0,MAXPATH)<0)
++          printf("Error argstr\n");
++        else
++          printf("%s",arg0);
++      }
++      else if (num == SYS_open || num == SYS_mkdir)
++      {
++        char arg0[128];
++        int arg1;
++         if(argstr(0,arg0,MAXPATH)<0)
++          printf("Error argstr\n");
++          else
++          {
++            argint(1,&arg1);
++          }
++          printf("%s, %d",arg0,arg1);
++
++      }
++      else if (num == SYS_link)
++      {
++         char arg0[128],arg1[128];
++          if(argstr(0,arg0,MAXPATH)<0 || argstr(1,arg1,MAXPATH)<0)
++          printf("Error argstr\n");
++          else
++          printf("%s, %s",arg0,arg1);
++
++      }
++
++      else if (num == SYS_read || num == SYS_write)
++      {
++        int arg0, arg2;
++        uint64 addr;
++        argint(0, &arg0);
++        argint(2, &arg2);
++        argaddr(1, &addr);
++
++        printf("%d, %p, %d", arg0, addr, arg2);
++
++      }
++}
+\ No newline at end of file
+diff --git a/kernel/syscall.h b/kernel/syscall.h
+index bc5f356..f389e15 100644
+--- a/kernel/syscall.h
++++ b/kernel/syscall.h
+@@ -20,3 +20,6 @@
+ #define SYS_link   19
+ #define SYS_mkdir  20
+ #define SYS_close  21
++#define SYS_trace  22       //add trace systemcall step-2
++#define SYS_history 23  //add history systemcall step-2
++#define SYS_terminate 24
+diff --git a/kernel/sysproc.c b/kernel/sysproc.c
+index 1de184e..0afbacd 100644
+--- a/kernel/sysproc.c
++++ b/kernel/sysproc.c
+@@ -6,6 +6,8 @@
+ #include "spinlock.h"
+ #include "proc.h"
+
++
++extern struct syscall_stat stats[];
+ uint64
+ sys_exit(void)
+ {
+@@ -89,3 +91,31 @@ sys_uptime(void)
+   release(&tickslock);
+   return xticks;
+ }
++uint64
++sys_trace(void)       /// add trace systemcall procedure step-5
++{
++  int traceId;
++  argint(0,&traceId);
++  if(traceId < 0)
++  return -1;
++  myproc()->traceId=traceId;
++  return 0;
++}
++uint64
++sys_history(void)
++{
++  int num;
++  uint64 addr;
++  argint(0,&num);
++  argaddr(1,&addr);
++  struct  syscall_stat st=stats[num];
++     if(copyout(myproc()->pagetable, addr, (char *)&st, sizeof(st)) < 0)
++      return -1;
++   return 0;
++}
++uint64
++sys_terminate(void)
++{
++  printf("sys_terminate called!");
++  return 0;
++}
+diff --git a/user/exit.c b/user/exit.c
+new file mode 100644
+index 0000000..a12e6d1
+--- /dev/null
++++ b/user/exit.c
+@@ -0,0 +1,23 @@
++#include "kernel/param.h"
++#include "kernel/types.h"
++#include "kernel/stat.h"
++#include "user/user.h"
++
++int
++main(int argc, char *argv[])
++{
++
++     if(argc == 1)
++     {
++
++
++       if(terminate()<0)
++          printf("Exit failed!");
++
++
++         exit(0);
++
++
++    }
++    exit(0);
++}
+diff --git a/user/history.c b/user/history.c
+new file mode 100644
+index 0000000..8bb01ad
+--- /dev/null
++++ b/user/history.c
+@@ -0,0 +1,50 @@
++#include "kernel/param.h"
++#include "kernel/types.h"
++#include "kernel/stat.h"
++#include "user/user.h"
++
++int
++main(int argc, char *argv[])
++{
++int SYSCALLCOUNT=24;
++       struct syscall_stat st;
++    if(argc== 2 )
++    {
++        if(history((atoi(argv[1])),&st)<0)
++        {
++        fprintf(2, "%s:  failed\n", argv[0]);
++        exit(1);
++        }
++        else
++        {
++          printf("%d:\tsyscall: %s, #: %d, time: %f\n",atoi(argv[1]),st.syscall_name,st.count,st.accum_time/10.0);
++        }
++
++    }
++    else if(argc == 1)
++     {
++
++         struct syscall_stat st;
++         for(int i=1; i<=SYSCALLCOUNT; i++)
++        {
++
++
++           if (history(i,&st)<0)
++           {
++            fprintf(2, "%s: failed\n", argv[0]);
++           }
++           else
++           {
++             printf("%d:\tsyscall: %s, #: %d, time: %d\n",i,st.syscall_name,st.count,st.accum_time);
++           }
++
++        }
++    }
++    else
++    {
++     fprintf(2, "Usage: %s sys_call_num \n", argv[0]);
++    }
++
++
++  exit(0);
++}
+diff --git a/user/myProg.c b/user/myProg.c
+new file mode 100644
+index 0000000..d9514b8
+--- /dev/null
++++ b/user/myProg.c
+@@ -0,0 +1,18 @@
++#include "kernel/types.h"
++#include "kernel/stat.h"
++#include "user/user.h"
++
++
++int main()
++{
++   printf("hello world\n");
++   char buf[10];
++   gets(buf, 9);
++   int num = atoi(buf);
++
++
++   printf("%d^2 = %d\n", num, num * num);
++
++
++   return 0;
++}
+diff --git a/user/trace.c b/user/trace.c
+new file mode 100644
+index 0000000..210395e
+--- /dev/null
++++ b/user/trace.c
+@@ -0,0 +1,28 @@
++#include "kernel/param.h"
++#include "kernel/types.h"
++#include "kernel/stat.h"
++#include "user/user.h"
++
++int
++main(int argc, char *argv[])
++{
++  int i;
++  char *nargv[MAXARG];
++
++  if(argc < 3 || (argv[1][0] < '0' || argv[1][0] > '9')){
++    fprintf(2, "Usage: %s sys_call_num command\n", argv[0]);
++    exit(1);
++  }
++
++   if (trace(atoi(argv[1])) < 0) {
++     fprintf(2, "%s: trace failed\n", argv[0]);
++     exit(1);
++  }
++
++  for(i = 2; i < argc && i < MAXARG; i++){
++    nargv[i-2] = argv[i];
++
++  }
++  exec(nargv[0], nargv);
++  exit(0);
++}
+diff --git a/user/user.h b/user/user.h
+index 4d398d5..7224d88 100644
+--- a/user/user.h
++++ b/user/user.h
+@@ -1,5 +1,11 @@
+ struct stat;
+
++struct syscall_stat{
++char syscall_name[16];
++int count;
++int accum_time;
++};
++
+ // system calls
+ int fork(void);
+ int exit(int) __attribute__((noreturn));
+@@ -22,6 +28,9 @@ int getpid(void);
+ char* sbrk(int);
+ int sleep(int);
+ int uptime(void);
++int trace(int);         //add trace system call step-1
++int history(int num,struct syscall_stat*);  //history syscall
++int terminate(void);
+
+ // ulib.c
+ int stat(const char*, struct stat*);
+diff --git a/user/usys.pl b/user/usys.pl
+index 01e426e..5eda327 100755
+--- a/user/usys.pl
++++ b/user/usys.pl
+@@ -36,3 +36,6 @@ entry("getpid");
+ entry("sbrk");
+ entry("sleep");
+ entry("uptime");
++entry("trace");     # add trace system call step-3
++entry("history");
++entry("terminate");
+\ No newline at end of file
diff --git a/1905042.patch b/1905042.patch
new file mode 100644
index 0000000..72b0c47
--- /dev/null
+++ b/1905042.patch
@@ -0,0 +1,469 @@
+diff --git a/.vscode/settings.json b/.vscode/settings.json
+new file mode 100644
+index 0000000..bfe7e6a
+--- /dev/null
++++ b/.vscode/settings.json
+@@ -0,0 +1,8 @@
++{
++    "files.associations": {
++        "user.h": "c",
++        "stat.h": "c",
++        "param.h": "c",
++        "types.h": "c"
++    }
++}
+\ No newline at end of file
+diff --git a/1905.patch b/1905.patch
+new file mode 100644
+index 0000000..769c182
+--- /dev/null
++++ b/1905.patch
+@@ -0,0 +1,635 @@
++diff --git a/.vscode/settings.json b/.vscode/settings.json
++new file mode 100644
++index 0000000..bfe7e6a
++--- /dev/null
+++++ b/.vscode/settings.json
++@@ -0,0 +1,8 @@
+++{
+++    "files.associations": {
+++        "user.h": "c",
+++        "stat.h": "c",
+++        "param.h": "c",
+++        "types.h": "c"
+++    }
+++}
++\ No newline at end of file
++diff --git a/1905042.patch b/1905042.patch
++new file mode 100644
++index 0000000..e69de29
++diff --git a/Makefile b/Makefile
++index 39a99d7..0311ce7 100644
++--- a/Makefile
+++++ b/Makefile
++@@ -132,6 +132,10 @@ UPROGS=\
++	$U/_grind\
++	$U/_wc\
++	$U/_zombie\
+++	$U/_myProg\
+++	$U/_trace\
+++	$U/_history\
+++	$U/_exit\
++
++ fs.img: mkfs/mkfs README $(UPROGS)
++	mkfs/mkfs fs.img README $(UPROGS)
++diff --git a/kernel/param.h b/kernel/param.h
++index 6624bff..b48f7ce 100644
++--- a/kernel/param.h
+++++ b/kernel/param.h
++@@ -10,4 +10,4 @@
++ #define LOGSIZE      (MAXOPBLOCKS*3)  // max data blocks in on-disk log
++ #define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache
++ #define FSSIZE       2000  // size of file system in blocks
++-#define MAXPATH      128   // maximum file path name
+++#define MAXPATH      128   // maximum file path name
++\ No newline at end of file
++diff --git a/kernel/proc.c b/kernel/proc.c
++index 959b778..1011b61 100644
++--- a/kernel/proc.c
+++++ b/kernel/proc.c
++@@ -322,6 +322,8 @@ fork(void)
++   np->state = RUNNABLE;
++   release(&np->lock);
++
+++
+++np->traceId=p->traceId; // trace the new process
++   return pid;
++ }
++
++diff --git a/kernel/proc.h b/kernel/proc.h
++index d021857..d26f9f5 100644
++--- a/kernel/proc.h
+++++ b/kernel/proc.h
++@@ -84,7 +84,9 @@ enum procstate { UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
++ // Per-process state
++ struct proc {
++   struct spinlock lock;
++-
+++  //vars for trace syscall
+++  int traceId;
+++  char *args;
++   // p->lock must be held when using these:
++   enum procstate state;        // Process state
++   void *chan;                  // If non-zero, sleeping on chan
++@@ -105,3 +107,9 @@ struct proc {
++   struct inode *cwd;           // Current directory
++   char name[16];               // Process name (debugging)
++ };
+++
+++struct syscall_stat{
+++char syscall_name[16];
+++int count;
+++int accum_time;
+++};
++\ No newline at end of file
++diff --git a/kernel/syscall.c b/kernel/syscall.c
++index ed65409..4aececd 100644
++--- a/kernel/syscall.c
+++++ b/kernel/syscall.c
++@@ -8,24 +8,22 @@
++ #include "defs.h"
++
++ // Fetch the uint64 at addr from the current process.
++-int
++-fetchaddr(uint64 addr, uint64 *ip)
+++int fetchaddr(uint64 addr, uint64 *ip)
++ {
++   struct proc *p = myproc();
++-  if(addr >= p->sz || addr+sizeof(uint64) > p->sz) // both tests needed, in case of overflow
+++  if (addr >= p->sz || addr + sizeof(uint64) > p->sz) // both tests needed, in case of overflow
++     return -1;
++-  if(copyin(p->pagetable, (char *)ip, addr, sizeof(*ip)) != 0)
+++  if (copyin(p->pagetable, (char *)ip, addr, sizeof(*ip)) != 0)
++     return -1;
++   return 0;
++ }
++
++ // Fetch the nul-terminated string at addr from the current process.
++ // Returns length of string, not including nul, or -1 for error.
++-int
++-fetchstr(uint64 addr, char *buf, int max)
+++int fetchstr(uint64 addr, char *buf, int max)
++ {
++   struct proc *p = myproc();
++-  if(copyinstr(p->pagetable, buf, addr, max) < 0)
+++  if (copyinstr(p->pagetable, buf, addr, max) < 0)
++     return -1;
++   return strlen(buf);
++ }
++@@ -34,7 +32,8 @@ static uint64
++ argraw(int n)
++ {
++   struct proc *p = myproc();
++-  switch (n) {
+++  switch (n)
+++  {
++   case 0:
++     return p->trapframe->a0;
++   case 1:
++@@ -53,8 +52,7 @@ argraw(int n)
++ }
++
++ // Fetch the nth 32-bit system call argument.
++-void
++-argint(int n, int *ip)
+++void argint(int n, int *ip)
++ {
++   *ip = argraw(n);
++ }
++@@ -62,8 +60,7 @@ argint(int n, int *ip)
++ // Retrieve an argument as a pointer.
++ // Doesn't check for legality, since
++ // copyin/copyout will do that.
++-void
++-argaddr(int n, uint64 *ip)
+++void argaddr(int n, uint64 *ip)
++ {
++   *ip = argraw(n);
++ }
++@@ -71,12 +68,14 @@ argaddr(int n, uint64 *ip)
++ // Fetch the nth word-sized system call argument as a null-terminated string.
++ // Copies into buf, at most max.
++ // Returns string length if OK (including nul), -1 if error.
++-int
++-argstr(int n, char *buf, int max)
+++int argstr(int n, char *buf, int max)
++ {
++   uint64 addr;
++   argaddr(n, &addr);
++-  return fetchstr(addr, buf, max);
+++  int ret = 0;
+++  fetchstr(addr, buf, max);
+++  // printf("%d  %d %s",n,max,buf);
+++  return ret;
++ }
++
++ // Prototypes for the functions that handle system calls.
++@@ -101,47 +100,204 @@ extern uint64 sys_unlink(void);
++ extern uint64 sys_link(void);
++ extern uint64 sys_mkdir(void);
++ extern uint64 sys_close(void);
+++extern uint64 sys_trace(void); // add trace systemcall step 4-a
+++extern uint64 sys_history(void); // add history systemcall step 4-a
+++extern uint64 sys_terminate(void);
++
++ // An array mapping syscall numbers from syscall.h
++ // to the function that handles the system call.
++ static uint64 (*syscalls[])(void) = {
++-[SYS_fork]    sys_fork,
++-[SYS_exit]    sys_exit,
++-[SYS_wait]    sys_wait,
++-[SYS_pipe]    sys_pipe,
++-[SYS_read]    sys_read,
++-[SYS_kill]    sys_kill,
++-[SYS_exec]    sys_exec,
++-[SYS_fstat]   sys_fstat,
++-[SYS_chdir]   sys_chdir,
++-[SYS_dup]     sys_dup,
++-[SYS_getpid]  sys_getpid,
++-[SYS_sbrk]    sys_sbrk,
++-[SYS_sleep]   sys_sleep,
++-[SYS_uptime]  sys_uptime,
++-[SYS_open]    sys_open,
++-[SYS_write]   sys_write,
++-[SYS_mknod]   sys_mknod,
++-[SYS_unlink]  sys_unlink,
++-[SYS_link]    sys_link,
++-[SYS_mkdir]   sys_mkdir,
++-[SYS_close]   sys_close,
+++    [SYS_fork] sys_fork,
+++    [SYS_exit] sys_exit,
+++    [SYS_wait] sys_wait,
+++    [SYS_pipe] sys_pipe,
+++    [SYS_read] sys_read,
+++    [SYS_kill] sys_kill,
+++    [SYS_exec] sys_exec,
+++    [SYS_fstat] sys_fstat,
+++    [SYS_chdir] sys_chdir,
+++    [SYS_dup] sys_dup,
+++    [SYS_getpid] sys_getpid,
+++    [SYS_sbrk] sys_sbrk,
+++    [SYS_sleep] sys_sleep,
+++    [SYS_uptime] sys_uptime,
+++    [SYS_open] sys_open,
+++    [SYS_write] sys_write,
+++    [SYS_mknod] sys_mknod,
+++    [SYS_unlink] sys_unlink,
+++    [SYS_link] sys_link,
+++    [SYS_mkdir] sys_mkdir,
+++    [SYS_close] sys_close,
+++    [SYS_trace] sys_trace, // add trace systemcall step 4-b
+++    [SYS_history] sys_history,
+++    [SYS_terminate] sys_terminate,
++ };
+++void printArgs(int num);
+++char *syscall_names[] = {"","fork", "exit", "wait", "pipe", "read", "kill", "exec", "fstat", "chdir", "dup", "getpid",
+++                         "sbrk", "sleep", "uptime", "open", "write", "mknod", "unlink", "link", "mkdir", "close", "trace","terminate"};
+++struct syscall_stat stats[] = {
+++  {"",0,0},
+++  {"fork",0,0},
+++  {"exit",0,0},
+++  {"wait",0,0},
+++  {"pipe",0,0},
+++  {"read",0,0},
+++  {"kill",0,0},
+++  {"exec",0,0},
+++  {"fstat",0,0},
+++  {"chdir",0,0},
+++  {"dup",0,0},
+++  {"getpid",0,0},
+++  {"sbrk",0,0},
+++  {"sleep",0,0},
+++  {"uptime",0,0},
+++  {"open",0,0},
+++  {"write",0,0},
+++  {"mknod",0,0},
+++  {"unlink",0,0},
+++  {"link",0,0},
+++  {"mkdir",0,0},
+++  {"close",0,0},
+++  {"trace",0,0},
+++  {"history",0,0},
+++  {"terminate",0,0},
++
++-void
++-syscall(void)
+++};
+++struct spinlock mylock;
+++
+++void syscall(void)
++ {
++   int num;
++   struct proc *p = myproc();
++
++   num = p->trapframe->a7;
++-  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
++-    // Use num to lookup the system call function for num, call it,
+++  if (num > 0 && num < NELEM(syscalls) && syscalls[num])
+++  {
+++
+++
+++
+++    if (p->traceId == num)
+++    {
+++
+++
+++      printf("pid: %d, syscall: %s, args: (", p->pid, syscall_names[num]);
+++     printArgs(num);
+++
+++    }
+++      // Use num to lookup the system call function for num, call it,
++     // and store its return value in p->trapframe->a0
+++    acquire(&mylock);
+++    stats[num].count++;
+++    release(&mylock);
+++
+++    uint iticks,fticks;
+++    acquire(&mylock);
+++    iticks=ticks;
+++    release(&mylock);
+++
++     p->trapframe->a0 = syscalls[num]();
++-  } else {
+++
+++     acquire(&mylock);
+++    fticks=ticks;
+++    release(&mylock);
+++     acquire(&mylock);
+++    stats[num].accum_time+=fticks-iticks;
+++    release(&mylock);
+++    if (p->traceId == num)
+++    {
+++      // printing trace systemcall details
+++      // printf("\npid: %d,syscall: %s,(%s) return value: %d\n",p->pid,,p->name,p->trapframe->a0);
+++      printf("), return: %d\n", p->trapframe->a0);
+++    }
+++  }
+++  else
+++  {
++     printf("%d %s: unknown sys call %d\n",
++-            p->pid, p->name, num);
+++           p->pid, p->name, num);
++     p->trapframe->a0 = -1;
++   }
++ }
+++
+++void printArgs(int num)
+++{
+++   if (num == SYS_exit || num == SYS_kill || num == SYS_sbrk || num == SYS_sleep || num == SYS_trace || num == SYS_dup ||num == SYS_close)
+++      {
+++        int arg;
+++        argint(0, &arg);
+++        printf("%d",arg);
+++
+++      }
+++      else if (num == SYS_wait || num == SYS_pipe)
+++      {
+++        uint64 addr;
+++        argaddr(0, &addr);
+++        printf("%p", addr);
+++
+++      }
+++      else if (num == SYS_fstat)
+++      {
+++        int arg0;
+++        uint64 arg1;
+++        argint(0,&arg0);
+++        argaddr(1,&arg1);
+++        printf("%d, %p",arg0,arg1);
+++      }
+++
+++       else if (num == SYS_exec)
+++      {
+++        char arg0[MAXPATH];
+++        uint64 arg1;
+++        argaddr(1, &arg1);
+++
+++         if (argstr(0, arg0, MAXPATH) < 0)
+++        {
+++          printf("error line 231 syscall.c ");
+++        }
+++        else
+++        {
+++          printf("%s, %p", arg0, arg1);
+++        }
+++      }
+++      else if (num == SYS_chdir || num == SYS_mknod || num == SYS_unlink)
+++      {
+++        char arg0[128];
+++        if(argstr(0,arg0,MAXPATH)<0)
+++          printf("Error argstr\n");
+++        else
+++          printf("%s",arg0);
+++      }
+++      else if (num == SYS_open || num == SYS_mkdir)
+++      {
+++        char arg0[128];
+++        int arg1;
+++         if(argstr(0,arg0,MAXPATH)<0)
+++          printf("Error argstr\n");
+++          else
+++          {
+++            argint(1,&arg1);
+++          }
+++          printf("%s, %d",arg0,arg1);
+++
+++      }
+++      else if (num == SYS_link)
+++      {
+++         char arg0[128],arg1[128];
+++          if(argstr(0,arg0,MAXPATH)<0 || argstr(1,arg1,MAXPATH)<0)
+++          printf("Error argstr\n");
+++          else
+++          printf("%s, %s",arg0,arg1);
+++
+++      }
+++
+++      else if (num == SYS_read || num == SYS_write)
+++      {
+++        int arg0, arg2;
+++        uint64 addr;
+++        argint(0, &arg0);
+++        argint(2, &arg2);
+++        argaddr(1, &addr);
+++
+++        printf("%d, %p, %d", arg0, addr, arg2);
+++
+++      }
+++}
++\ No newline at end of file
++diff --git a/kernel/syscall.h b/kernel/syscall.h
++index bc5f356..f389e15 100644
++--- a/kernel/syscall.h
+++++ b/kernel/syscall.h
++@@ -20,3 +20,6 @@
++ #define SYS_link   19
++ #define SYS_mkdir  20
++ #define SYS_close  21
+++#define SYS_trace  22       //add trace systemcall step-2
+++#define SYS_history 23  //add history systemcall step-2
+++#define SYS_terminate 24
++diff --git a/kernel/sysproc.c b/kernel/sysproc.c
++index 1de184e..0afbacd 100644
++--- a/kernel/sysproc.c
+++++ b/kernel/sysproc.c
++@@ -6,6 +6,8 @@
++ #include "spinlock.h"
++ #include "proc.h"
++
+++
+++extern struct syscall_stat stats[];
++ uint64
++ sys_exit(void)
++ {
++@@ -89,3 +91,31 @@ sys_uptime(void)
++   release(&tickslock);
++   return xticks;
++ }
+++uint64
+++sys_trace(void)       /// add trace systemcall procedure step-5
+++{
+++  int traceId;
+++  argint(0,&traceId);
+++  if(traceId < 0)
+++  return -1;
+++  myproc()->traceId=traceId;
+++  return 0;
+++}
+++uint64
+++sys_history(void)
+++{
+++  int num;
+++  uint64 addr;
+++  argint(0,&num);
+++  argaddr(1,&addr);
+++  struct  syscall_stat st=stats[num];
+++     if(copyout(myproc()->pagetable, addr, (char *)&st, sizeof(st)) < 0)
+++      return -1;
+++   return 0;
+++
\ No newline at end of file
diff --git a/Makefile b/Makefile
index 39a99d7..0311ce7 100644
--- a/Makefile
+++ b/Makefile
@@ -132,6 +132,10 @@ UPROGS=\
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\
+	$U/_myProg\
+	$U/_trace\
+	$U/_history\
+	$U/_exit\
 
 fs.img: mkfs/mkfs README $(UPROGS)
 	mkfs/mkfs fs.img README $(UPROGS)
diff --git a/kernel/param.h b/kernel/param.h
index 6624bff..b48f7ce 100644
--- a/kernel/param.h
+++ b/kernel/param.h
@@ -10,4 +10,4 @@
 #define LOGSIZE      (MAXOPBLOCKS*3)  // max data blocks in on-disk log
 #define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache
 #define FSSIZE       2000  // size of file system in blocks
-#define MAXPATH      128   // maximum file path name
+#define MAXPATH      128   // maximum file path name
\ No newline at end of file
diff --git a/kernel/proc.c b/kernel/proc.c
index 959b778..476ff3f 100644
--- a/kernel/proc.c
+++ b/kernel/proc.c
@@ -322,6 +322,8 @@ fork(void)
   np->state = RUNNABLE;
   release(&np->lock);
 
+
+np->traceNum=p->traceNum; // tracing the new process
   return pid;
 }
 
diff --git a/kernel/proc.h b/kernel/proc.h
index d021857..9d9b94a 100644
--- a/kernel/proc.h
+++ b/kernel/proc.h
@@ -84,7 +84,9 @@ enum procstate { UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
 // Per-process state
 struct proc {
   struct spinlock lock;
-
+  //vars for trace syscall
+  int traceNum;
+  char *args;
   // p->lock must be held when using these:
   enum procstate state;        // Process state
   void *chan;                  // If non-zero, sleeping on chan
@@ -105,3 +107,9 @@ struct proc {
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
 };
+
+struct syscall_stat{
+char syscall_name[16];
+int count;
+int accum_time;
+};
\ No newline at end of file
diff --git a/kernel/syscall.c b/kernel/syscall.c
index ed65409..8b6376d 100644
--- a/kernel/syscall.c
+++ b/kernel/syscall.c
@@ -8,24 +8,22 @@
 #include "defs.h"
 
 // Fetch the uint64 at addr from the current process.
-int
-fetchaddr(uint64 addr, uint64 *ip)
+int fetchaddr(uint64 addr, uint64 *ip)
 {
   struct proc *p = myproc();
-  if(addr >= p->sz || addr+sizeof(uint64) > p->sz) // both tests needed, in case of overflow
+  if (addr >= p->sz || addr + sizeof(uint64) > p->sz) // both tests needed, in case of overflow
     return -1;
-  if(copyin(p->pagetable, (char *)ip, addr, sizeof(*ip)) != 0)
+  if (copyin(p->pagetable, (char *)ip, addr, sizeof(*ip)) != 0)
     return -1;
   return 0;
 }
 
 // Fetch the nul-terminated string at addr from the current process.
 // Returns length of string, not including nul, or -1 for error.
-int
-fetchstr(uint64 addr, char *buf, int max)
+int fetchstr(uint64 addr, char *buf, int max)
 {
   struct proc *p = myproc();
-  if(copyinstr(p->pagetable, buf, addr, max) < 0)
+  if (copyinstr(p->pagetable, buf, addr, max) < 0)
     return -1;
   return strlen(buf);
 }
@@ -34,7 +32,8 @@ static uint64
 argraw(int n)
 {
   struct proc *p = myproc();
-  switch (n) {
+  switch (n)
+  {
   case 0:
     return p->trapframe->a0;
   case 1:
@@ -53,8 +52,7 @@ argraw(int n)
 }
 
 // Fetch the nth 32-bit system call argument.
-void
-argint(int n, int *ip)
+void argint(int n, int *ip)
 {
   *ip = argraw(n);
 }
@@ -62,8 +60,7 @@ argint(int n, int *ip)
 // Retrieve an argument as a pointer.
 // Doesn't check for legality, since
 // copyin/copyout will do that.
-void
-argaddr(int n, uint64 *ip)
+void argaddr(int n, uint64 *ip)
 {
   *ip = argraw(n);
 }
@@ -71,12 +68,14 @@ argaddr(int n, uint64 *ip)
 // Fetch the nth word-sized system call argument as a null-terminated string.
 // Copies into buf, at most max.
 // Returns string length if OK (including nul), -1 if error.
-int
-argstr(int n, char *buf, int max)
+int argstr(int n, char *buf, int max)
 {
   uint64 addr;
   argaddr(n, &addr);
-  return fetchstr(addr, buf, max);
+  int ret = 0;
+  fetchstr(addr, buf, max);
+  // printf("%d  %d %s",n,max,buf);
+  return ret;
 }
 
 // Prototypes for the functions that handle system calls.
@@ -101,47 +100,204 @@ extern uint64 sys_unlink(void);
 extern uint64 sys_link(void);
 extern uint64 sys_mkdir(void);
 extern uint64 sys_close(void);
+extern uint64 sys_trace(void); // add trace systemcall step 4-a
+extern uint64 sys_history(void); // add history systemcall step 4-a
+extern uint64 sys_terminate(void);
 
 // An array mapping syscall numbers from syscall.h
 // to the function that handles the system call.
 static uint64 (*syscalls[])(void) = {
-[SYS_fork]    sys_fork,
-[SYS_exit]    sys_exit,
-[SYS_wait]    sys_wait,
-[SYS_pipe]    sys_pipe,
-[SYS_read]    sys_read,
-[SYS_kill]    sys_kill,
-[SYS_exec]    sys_exec,
-[SYS_fstat]   sys_fstat,
-[SYS_chdir]   sys_chdir,
-[SYS_dup]     sys_dup,
-[SYS_getpid]  sys_getpid,
-[SYS_sbrk]    sys_sbrk,
-[SYS_sleep]   sys_sleep,
-[SYS_uptime]  sys_uptime,
-[SYS_open]    sys_open,
-[SYS_write]   sys_write,
-[SYS_mknod]   sys_mknod,
-[SYS_unlink]  sys_unlink,
-[SYS_link]    sys_link,
-[SYS_mkdir]   sys_mkdir,
-[SYS_close]   sys_close,
+    [SYS_fork] sys_fork,
+    [SYS_exit] sys_exit,
+    [SYS_wait] sys_wait,
+    [SYS_pipe] sys_pipe,
+    [SYS_read] sys_read,
+    [SYS_kill] sys_kill,
+    [SYS_exec] sys_exec,
+    [SYS_fstat] sys_fstat,
+    [SYS_chdir] sys_chdir,
+    [SYS_dup] sys_dup,
+    [SYS_getpid] sys_getpid,
+    [SYS_sbrk] sys_sbrk,
+    [SYS_sleep] sys_sleep,
+    [SYS_uptime] sys_uptime,
+    [SYS_open] sys_open,
+    [SYS_write] sys_write,
+    [SYS_mknod] sys_mknod,
+    [SYS_unlink] sys_unlink,
+    [SYS_link] sys_link,
+    [SYS_mkdir] sys_mkdir,
+    [SYS_close] sys_close,
+    [SYS_trace] sys_trace, // add trace systemcall step 4-b
+    [SYS_history] sys_history,
+    [SYS_terminate] sys_terminate,
 };
+void printArgs(int num);
+char *syscall_names[] = {"","fork", "exit", "wait", "pipe", "read", "kill", "exec", "fstat", "chdir", "dup", "getpid",
+                         "sbrk", "sleep", "uptime", "open", "write", "mknod", "unlink", "link", "mkdir", "close", "trace","terminate"};
+struct syscall_stat stats[] = {
+  {"",0,0},
+  {"fork",0,0},
+  {"exit",0,0},
+  {"wait",0,0},
+  {"pipe",0,0},
+  {"read",0,0},
+  {"kill",0,0},
+  {"exec",0,0},
+  {"fstat",0,0},
+  {"chdir",0,0},
+  {"dup",0,0},
+  {"getpid",0,0},
+  {"sbrk",0,0},
+  {"sleep",0,0},
+  {"uptime",0,0},
+  {"open",0,0},
+  {"write",0,0},
+  {"mknod",0,0},
+  {"unlink",0,0},
+  {"link",0,0},
+  {"mkdir",0,0},
+  {"close",0,0},
+  {"trace",0,0},
+  {"history",0,0},
+  {"terminate",0,0},
 
-void
-syscall(void)
+};
+struct spinlock mylock;
+
+void syscall(void)
 {
   int num;
   struct proc *p = myproc();
 
   num = p->trapframe->a7;
-  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
-    // Use num to lookup the system call function for num, call it,
+  if (num > 0 && num < NELEM(syscalls) && syscalls[num])
+  {
+
+
+
+    if (p->traceNum == num)
+    {
+
+
+      printf("pid: %d, syscall: %s, args: (", p->pid, syscall_names[num]);
+     printArgs(num);
+
+    }
+      // Use num to lookup the system call function for num, call it,
     // and store its return value in p->trapframe->a0
+    acquire(&mylock);
+    stats[num].count++;
+    release(&mylock);
+
+    uint iticks,fticks;
+    acquire(&mylock);
+    iticks=ticks;
+    release(&mylock);
+
     p->trapframe->a0 = syscalls[num]();
-  } else {
+
+     acquire(&mylock);
+    fticks=ticks;
+    release(&mylock);
+     acquire(&mylock);
+    stats[num].accum_time+=fticks-iticks;
+    release(&mylock);
+    if (p->traceNum == num)
+    {
+      // printing trace systemcall details
+      // printf("\npid: %d,syscall: %s,(%s) return value: %d\n",p->pid,,p->name,p->trapframe->a0);
+      printf("), return: %d\n", p->trapframe->a0);
+    }
+  }
+  else
+  {
     printf("%d %s: unknown sys call %d\n",
-            p->pid, p->name, num);
+           p->pid, p->name, num);
     p->trapframe->a0 = -1;
   }
 }
+
+void printArgs(int num)
+{
+   if (num == SYS_exit || num == SYS_kill || num == SYS_sbrk || num == SYS_sleep || num == SYS_trace || num == SYS_dup ||num == SYS_close)
+      {
+        int arg;
+        argint(0, &arg);
+        printf("%d",arg);
+
+      }
+      else if (num == SYS_wait || num == SYS_pipe)
+      {
+        uint64 addr;
+        argaddr(0, &addr);
+        printf("%p", addr);
+
+      }
+      else if (num == SYS_fstat)
+      {
+        int arg0;
+        uint64 arg1;
+        argint(0,&arg0);
+        argaddr(1,&arg1);
+        printf("%d, %p",arg0,arg1);
+      }
+
+       else if (num == SYS_exec)
+      {
+        char arg0[MAXPATH];
+        uint64 arg1;
+        argaddr(1, &arg1);
+
+         if (argstr(0, arg0, MAXPATH) < 0)
+        {
+          printf("error line 231 syscall.c ");
+        }
+        else
+        {
+          printf("%s, %p", arg0, arg1);
+        }
+      }
+      else if (num == SYS_chdir || num == SYS_mknod || num == SYS_unlink)
+      {
+        char arg0[128];
+        if(argstr(0,arg0,MAXPATH)<0)
+          printf("Error argstr\n");
+        else
+          printf("%s",arg0);
+      }
+      else if (num == SYS_open || num == SYS_mkdir)
+      {
+        char arg0[128];
+        int arg1;
+         if(argstr(0,arg0,MAXPATH)<0)
+          printf("Error argstr\n");
+          else
+          {
+            argint(1,&arg1);
+          }
+          printf("%s, %d",arg0,arg1);
+
+      }
+      else if (num == SYS_link)
+      {
+         char arg0[128],arg1[128];
+          if(argstr(0,arg0,MAXPATH)<0 || argstr(1,arg1,MAXPATH)<0)
+          printf("Error argstr\n");
+          else
+          printf("%s, %s",arg0,arg1);
+
+      }
+
+      else if (num == SYS_read || num == SYS_write)
+      {
+        int arg0, arg2;
+        uint64 addr;
+        argint(0, &arg0);
+        argint(2, &arg2);
+        argaddr(1, &addr);
+
+        printf("%d, %p, %d", arg0, addr, arg2);
+
+      }
+}
\ No newline at end of file
diff --git a/kernel/syscall.h b/kernel/syscall.h
index bc5f356..f389e15 100644
--- a/kernel/syscall.h
+++ b/kernel/syscall.h
@@ -20,3 +20,6 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_trace  22       //add trace systemcall step-2
+#define SYS_history 23  //add history systemcall step-2
+#define SYS_terminate 24
diff --git a/kernel/sysproc.c b/kernel/sysproc.c
index 1de184e..20d006e 100644
--- a/kernel/sysproc.c
+++ b/kernel/sysproc.c
@@ -6,6 +6,8 @@
 #include "spinlock.h"
 #include "proc.h"
 
+
+extern struct syscall_stat stats[];
 uint64
 sys_exit(void)
 {
@@ -89,3 +91,31 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+uint64
+sys_trace(void)       /// add trace systemcall procedure step-5
+{
+  int num;
+  argint(0,&num);
+  if(num < 0)
+  return -1;
+  myproc()->traceNum=num;
+  return 0;
+}
+uint64
+sys_history(void)
+{
+  int num;
+  uint64 addr;
+  argint(0,&num);
+  argaddr(1,&addr);
+  struct  syscall_stat st=stats[num];
+     if(copyout(myproc()->pagetable, addr, (char *)&st, sizeof(st)) < 0)
+      return -1;
+   return 0;
+}
+uint64
+sys_terminate(void)
+{
+  printf("sys_terminate called!");
+  return 0;
+}
diff --git a/user/exit.c b/user/exit.c
new file mode 100644
index 0000000..8d4081c
--- /dev/null
+++ b/user/exit.c
@@ -0,0 +1,23 @@
+#include "kernel/param.h"
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+
+int
+main(int argc, char *argv[])
+{
+
+     if(argc == 1)
+     {
+
+
+       if(terminate()<0)
+          printf("Exit failed!");
+
+
+         exit(0);
+
+
+    }
+    exit(0);
+}
diff --git a/user/history.c b/user/history.c
new file mode 100644
index 0000000..11939b3
--- /dev/null
+++ b/user/history.c
@@ -0,0 +1,50 @@
+#include "kernel/param.h"
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+
+int
+main(int argc, char *argv[])
+{
+int SYSCALLCOUNT=24;
+       struct syscall_stat st;
+    if(argc== 2 )
+    {
+        if(history((atoi(argv[1])),&st)<0)
+        {
+        fprintf(2, "%s:  failed\n", argv[0]);
+        exit(1);
+        }
+        else
+        {
+          printf("%d:\tsyscall: %s, #: %d, time: %d\n",atoi(argv[1]),st.syscall_name,st.count,st.accum_time/10);
+        }
+
+    }
+    else if(argc == 1)
+     {
+
+         struct syscall_stat st;
+         for(int i=1; i<=SYSCALLCOUNT; i++)
+        {
+
+
+           if (history(i,&st)<0)
+           {
+            fprintf(2, "%s: failed\n", argv[0]);
+           }
+           else
+           {
+             printf("%d:\tsyscall: %s, #: %d, time: %d\n",i,st.syscall_name,st.count,st.accum_time);
+           }
+
+        }
+    }
+    else
+    {
+     fprintf(2, "Usage: %s sys_call_num \n", argv[0]);
+    }
+
+
+  exit(0);
+}
diff --git a/user/myProg.c b/user/myProg.c
new file mode 100644
index 0000000..d9514b8
--- /dev/null
+++ b/user/myProg.c
@@ -0,0 +1,18 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+
+
+int main()
+{
+   printf("hello world\n");
+   char buf[10];
+   gets(buf, 9);
+   int num = atoi(buf);
+
+
+   printf("%d^2 = %d\n", num, num * num);
+
+
+   return 0;
+}
diff --git a/user/trace.c b/user/trace.c
new file mode 100644
index 0000000..210395e
--- /dev/null
+++ b/user/trace.c
@@ -0,0 +1,28 @@
+#include "kernel/param.h"
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+
+int
+main(int argc, char *argv[])
+{
+  int i;
+  char *nargv[MAXARG];
+
+  if(argc < 3 || (argv[1][0] < '0' || argv[1][0] > '9')){
+    fprintf(2, "Usage: %s sys_call_num command\n", argv[0]);
+    exit(1);
+  }
+
+   if (trace(atoi(argv[1])) < 0) {
+     fprintf(2, "%s: trace failed\n", argv[0]);
+     exit(1);
+  }
+
+  for(i = 2; i < argc && i < MAXARG; i++){
+    nargv[i-2] = argv[i];
+
+  }
+  exec(nargv[0], nargv);
+  exit(0);
+}
diff --git a/user/user.h b/user/user.h
index 4d398d5..7224d88 100644
--- a/user/user.h
+++ b/user/user.h
@@ -1,5 +1,11 @@
 struct stat;
 
+struct syscall_stat{
+char syscall_name[16];
+int count;
+int accum_time;
+};
+
 // system calls
 int fork(void);
 int exit(int) __attribute__((noreturn));
@@ -22,6 +28,9 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int trace(int);         //add trace system call step-1
+int history(int num,struct syscall_stat*);  //history syscall
+int terminate(void);
 
 // ulib.c
 int stat(const char*, struct stat*);
diff --git a/user/usys.pl b/user/usys.pl
index 01e426e..5eda327 100755
--- a/user/usys.pl
+++ b/user/usys.pl
@@ -36,3 +36,6 @@ entry("getpid");
 entry("sbrk");
 entry("sleep");
 entry("uptime");
+entry("trace");     # add trace system call step-3
+entry("history");
+entry("terminate");
\ No newline at end of file
